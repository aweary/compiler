{"version":3,"file":"signals-core.js","sources":["../src/index.ts"],"sourcesContent":["/** This tracks subscriptions of signals read inside a computed */\nlet currentSignal: Signal | undefined;\nlet commitError: Error | null = null;\n\nlet batchPending: Set<Signal> | null = null;\n\nlet oldDeps = new Set<Signal>();\n\nexport class Signal<T = any> {\n\t// These property names get minified - see /mangle.json\n\n\t/** @internal Internal, do not use. */\n\t_subs = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_deps = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_pending = 0;\n\t/** @internal Internal, do not use. */\n\t_value: T;\n\t/** @internal Determine if a computed is allowed to write or not */\n\t_readonly = false;\n\t/** @internal Marks the signal as requiring an update */\n\t_requiresUpdate = false;\n\t/** @internal Determine if reads should eagerly activate value */\n\t_active = false;\n\t/** @internal Used to detect if there is a cycle in the graph */\n\t_isComputing = false;\n\n\tconstructor(value: T) {\n\t\tthis._value = value;\n\t}\n\n\ttoString() {\n\t\treturn \"\" + this.value;\n\t}\n\n\tpeek() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tget value() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\n\t\t// If we read a signal outside of a computed we have no way\n\t\t// to unsubscribe from that. So we assume that the user wants\n\t\t// to get the value immediately like for testing.\n\t\tif (!currentSignal) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\t// subscribe the current computed to this signal:\n\t\tthis._subs.add(currentSignal);\n\t\t// update the current computed's dependencies:\n\t\tcurrentSignal._deps.add(this);\n\t\toldDeps.delete(this);\n\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tif (this._readonly) {\n\t\t\tthrow Error(\"Computed signals are readonly\");\n\t\t}\n\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\n\t\t\tbatch(() => {\n\t\t\t\tbatchPending!.add(this);\n\n\t\t\t\t// in batch mode this signal may be marked already\n\t\t\t\tif (this._pending === 0) {\n\t\t\t\t\tmark(this);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Start a read operation where this signal is the \"current signal\" context.\n\t * Returns a function that must be called to end the read context.\n\t * @internal\n\t */\n\t_setCurrent() {\n\t\tlet prevSignal = currentSignal;\n\t\tlet prevOldDeps = oldDeps;\n\t\tcurrentSignal = this;\n\t\toldDeps = this._deps;\n\t\tthis._deps = new Set();\n\n\t\treturn (shouldUnmark: boolean, shouldCleanup: boolean) => {\n\t\t\tif (shouldUnmark) this._subs.forEach(unmark);\n\n\t\t\t// Any leftover dependencies here are not needed anymore\n\t\t\tif (shouldCleanup) {\n\t\t\t\t// Unsubscribe from dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => unsubscribe(this, dep));\n\t\t\t} else {\n\t\t\t\t// Re-subscribe to dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => subscribe(this, dep));\n\t\t\t}\n\n\t\t\toldDeps.clear();\n\t\t\toldDeps = prevOldDeps;\n\t\t\tcurrentSignal = prevSignal;\n\t\t};\n\t}\n\n\tsubscribe(fn: (value: T) => void): () => void {\n\t\treturn effect(() => fn(this.value));\n\t}\n\n\t/**\n\t * A custom update routine to run when this Signal's value changes.\n\t * @internal\n\t */\n\t_updater() {\n\t\t// override me to handle updates\n\t}\n}\n\nfunction mark(signal: Signal) {\n\tif (signal._pending++ === 0) {\n\t\tsignal._subs.forEach(mark);\n\t}\n}\n\nfunction unmark(signal: Signal<any>) {\n\t// We can only unmark this node as not needing an update if it\n\t// wasn't flagged as needing an update by someone else. This is\n\t// done to make the sweeping logic independent of the order\n\t// in which a dependency tries to unmark a subtree.\n\tif (\n\t\t!signal._requiresUpdate &&\n\t\tsignal._pending > 0 &&\n\t\t--signal._pending === 0\n\t) {\n\t\tsignal._subs.forEach(unmark);\n\t}\n}\n\nfunction sweep(subs: Set<Signal<any>>) {\n\tsubs.forEach(signal => {\n\t\t// If a computed errored during sweep, we'll discard that subtree\n\t\t// for this sweep cycle by setting PENDING to 0;\n\t\tif (signal._pending > 1) return --signal._pending;\n\t\tlet ready = true;\n\t\tsignal._deps.forEach(dep => {\n\t\t\tif (dep._pending > 0) ready = false;\n\t\t});\n\n\t\tif (ready && signal._pending > 0 && --signal._pending === 0) {\n\t\t\tif (signal._isComputing) {\n\t\t\t\tthrow Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tsignal._requiresUpdate = false;\n\t\t\tsignal._isComputing = true;\n\t\t\tsignal._updater();\n\t\t\tsignal._isComputing = false;\n\t\t\tsweep(signal._subs);\n\t\t}\n\t});\n}\n\nfunction subscribe(signal: Signal<any>, to: Signal<any>) {\n\tsignal._active = true;\n\tsignal._deps.add(to);\n\tto._subs.add(signal);\n}\n\nfunction unsubscribe(signal: Signal<any>, from: Signal<any>) {\n\tsignal._deps.delete(from);\n\tfrom._subs.delete(signal);\n\n\t// If nobody listens to the signal we depended on, we can traverse\n\t// upwards and destroy all subscriptions until we encounter a writable\n\t// signal or a signal that others listen to as well.\n\tif (from._subs.size === 0) {\n\t\tfrom._active = false;\n\t\tfrom._deps.forEach(dep => unsubscribe(from, dep));\n\t}\n}\n\nconst tmpPending: Signal[] = [];\n/**\n * Refresh _just_ this signal and its dependencies recursively.\n * All other signals will be left untouched and added to the\n * global queue to flush later. Since we're traversing \"upwards\",\n * we don't have to care about topological sorting.\n */\nfunction refreshStale(signal: Signal) {\n\tif (batchPending) {\n\t\tbatchPending.delete(signal);\n\t}\n\n\tsignal._pending = 0;\n\tsignal._updater();\n\tif (commitError) {\n\t\tconst err = commitError;\n\t\tcommitError = null;\n\t\tthrow err;\n\t}\n\n\tsignal._subs.forEach(sub => {\n\t\tif (sub._pending > 0) {\n\t\t\t// If PENDING > 1 then we can safely reduce the counter because\n\t\t\t// the final sweep will take care of the rest. But if it's\n\t\t\t// exactly 1 we can't do that otherwise the sweeping logic\n\t\t\t// assumes that this signal was already updated.\n\t\t\tif (sub._pending > 1) sub._pending--;\n\t\t\ttmpPending.push(sub);\n\t\t}\n\t});\n}\n\nfunction activate(signal: Signal) {\n\tsignal._active = true;\n\trefreshStale(signal);\n}\n\nexport function signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nexport type ReadonlySignal<T = any> = Omit<Signal<T>, \"value\"> & {\n\treadonly value: T;\n};\nexport function computed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst signal = new Signal<T>(undefined as any);\n\tsignal._readonly = true;\n\n\tfunction updater() {\n\t\tlet finish = signal._setCurrent();\n\n\t\ttry {\n\t\t\tlet ret = compute();\n\t\t\tconst stale = signal._value === ret;\n\t\t\tif (!stale) signal._subs.forEach(sub => (sub._requiresUpdate = true));\n\t\t\tfinish(stale, true);\n\t\t\tsignal._value = ret;\n\t\t} catch (err: any) {\n\t\t\t// Ensure that we log the first error not the last\n\t\t\tif (!commitError) commitError = err;\n\t\t\tfinish(true, false);\n\t\t}\n\t}\n\n\tsignal._updater = updater;\n\n\treturn signal;\n}\n\nexport function effect(callback: () => void) {\n\tconst s = computed(() => batch(callback));\n\t// Set up subscriptions since this is a \"reactor\" signal\n\tactivate(s);\n\treturn () => s._setCurrent()(true, true);\n}\n\nexport function batch<T>(cb: () => T): T {\n\tif (batchPending !== null) {\n\t\treturn cb();\n\t} else {\n\t\tconst pending: Set<Signal> = new Set();\n\n\t\tbatchPending = pending;\n\n\t\ttry {\n\t\t\treturn cb();\n\t\t} finally {\n\t\t\t// Since stale signals are refreshed upwards, we need to\n\t\t\t// add pending signals in reverse\n\t\t\tlet item: Signal | undefined;\n\t\t\twhile ((item = tmpPending.pop()) !== undefined) {\n\t\t\t\tpending.add(item);\n\t\t\t}\n\n\t\t\tbatchPending = null;\n\n\t\t\tsweep(pending);\n\t\t\tif (commitError) {\n\t\t\t\tconst err = commitError;\n\t\t\t\t// Clear global error flag for next commit\n\t\t\t\tcommitError = null;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":["currentSignal","commitError","batchPending","oldDeps","Set","Signal","value","this","_subs","_deps","_pending","_value","_readonly","_requiresUpdate","_active","_isComputing","toString","peek","activate","_setCurrent","prevSignal","prevOldDeps","shouldUnmark","shouldCleanup","_this","forEach","unmark","dep","unsubscribe","subscribe","to","signal","add","clear","fn","_this2","_proto","_updater","key","get","set","Error","batch","_this3","mark","sweep","subs","ready","from","size","tmpPending","refreshStale","err","sub","push","computed","compute","undefined","finish","ret","stale","effect","callback","s","cb","pending","item","pop","exports"],"mappings":"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"}