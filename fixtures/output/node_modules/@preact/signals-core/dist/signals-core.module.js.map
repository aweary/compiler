{"version":3,"file":"signals-core.module.js","sources":["../src/index.ts"],"sourcesContent":["/** This tracks subscriptions of signals read inside a computed */\nlet currentSignal: Signal | undefined;\nlet commitError: Error | null = null;\n\nlet batchPending: Set<Signal> | null = null;\n\nlet oldDeps = new Set<Signal>();\n\nexport class Signal<T = any> {\n\t// These property names get minified - see /mangle.json\n\n\t/** @internal Internal, do not use. */\n\t_subs = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_deps = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_pending = 0;\n\t/** @internal Internal, do not use. */\n\t_value: T;\n\t/** @internal Determine if a computed is allowed to write or not */\n\t_readonly = false;\n\t/** @internal Marks the signal as requiring an update */\n\t_requiresUpdate = false;\n\t/** @internal Determine if reads should eagerly activate value */\n\t_active = false;\n\t/** @internal Used to detect if there is a cycle in the graph */\n\t_isComputing = false;\n\n\tconstructor(value: T) {\n\t\tthis._value = value;\n\t}\n\n\ttoString() {\n\t\treturn \"\" + this.value;\n\t}\n\n\tpeek() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tget value() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\n\t\t// If we read a signal outside of a computed we have no way\n\t\t// to unsubscribe from that. So we assume that the user wants\n\t\t// to get the value immediately like for testing.\n\t\tif (!currentSignal) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\t// subscribe the current computed to this signal:\n\t\tthis._subs.add(currentSignal);\n\t\t// update the current computed's dependencies:\n\t\tcurrentSignal._deps.add(this);\n\t\toldDeps.delete(this);\n\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tif (this._readonly) {\n\t\t\tthrow Error(\"Computed signals are readonly\");\n\t\t}\n\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\n\t\t\tbatch(() => {\n\t\t\t\tbatchPending!.add(this);\n\n\t\t\t\t// in batch mode this signal may be marked already\n\t\t\t\tif (this._pending === 0) {\n\t\t\t\t\tmark(this);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Start a read operation where this signal is the \"current signal\" context.\n\t * Returns a function that must be called to end the read context.\n\t * @internal\n\t */\n\t_setCurrent() {\n\t\tlet prevSignal = currentSignal;\n\t\tlet prevOldDeps = oldDeps;\n\t\tcurrentSignal = this;\n\t\toldDeps = this._deps;\n\t\tthis._deps = new Set();\n\n\t\treturn (shouldUnmark: boolean, shouldCleanup: boolean) => {\n\t\t\tif (shouldUnmark) this._subs.forEach(unmark);\n\n\t\t\t// Any leftover dependencies here are not needed anymore\n\t\t\tif (shouldCleanup) {\n\t\t\t\t// Unsubscribe from dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => unsubscribe(this, dep));\n\t\t\t} else {\n\t\t\t\t// Re-subscribe to dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => subscribe(this, dep));\n\t\t\t}\n\n\t\t\toldDeps.clear();\n\t\t\toldDeps = prevOldDeps;\n\t\t\tcurrentSignal = prevSignal;\n\t\t};\n\t}\n\n\tsubscribe(fn: (value: T) => void): () => void {\n\t\treturn effect(() => fn(this.value));\n\t}\n\n\t/**\n\t * A custom update routine to run when this Signal's value changes.\n\t * @internal\n\t */\n\t_updater() {\n\t\t// override me to handle updates\n\t}\n}\n\nfunction mark(signal: Signal) {\n\tif (signal._pending++ === 0) {\n\t\tsignal._subs.forEach(mark);\n\t}\n}\n\nfunction unmark(signal: Signal<any>) {\n\t// We can only unmark this node as not needing an update if it\n\t// wasn't flagged as needing an update by someone else. This is\n\t// done to make the sweeping logic independent of the order\n\t// in which a dependency tries to unmark a subtree.\n\tif (\n\t\t!signal._requiresUpdate &&\n\t\tsignal._pending > 0 &&\n\t\t--signal._pending === 0\n\t) {\n\t\tsignal._subs.forEach(unmark);\n\t}\n}\n\nfunction sweep(subs: Set<Signal<any>>) {\n\tsubs.forEach(signal => {\n\t\t// If a computed errored during sweep, we'll discard that subtree\n\t\t// for this sweep cycle by setting PENDING to 0;\n\t\tif (signal._pending > 1) return --signal._pending;\n\t\tlet ready = true;\n\t\tsignal._deps.forEach(dep => {\n\t\t\tif (dep._pending > 0) ready = false;\n\t\t});\n\n\t\tif (ready && signal._pending > 0 && --signal._pending === 0) {\n\t\t\tif (signal._isComputing) {\n\t\t\t\tthrow Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tsignal._requiresUpdate = false;\n\t\t\tsignal._isComputing = true;\n\t\t\tsignal._updater();\n\t\t\tsignal._isComputing = false;\n\t\t\tsweep(signal._subs);\n\t\t}\n\t});\n}\n\nfunction subscribe(signal: Signal<any>, to: Signal<any>) {\n\tsignal._active = true;\n\tsignal._deps.add(to);\n\tto._subs.add(signal);\n}\n\nfunction unsubscribe(signal: Signal<any>, from: Signal<any>) {\n\tsignal._deps.delete(from);\n\tfrom._subs.delete(signal);\n\n\t// If nobody listens to the signal we depended on, we can traverse\n\t// upwards and destroy all subscriptions until we encounter a writable\n\t// signal or a signal that others listen to as well.\n\tif (from._subs.size === 0) {\n\t\tfrom._active = false;\n\t\tfrom._deps.forEach(dep => unsubscribe(from, dep));\n\t}\n}\n\nconst tmpPending: Signal[] = [];\n/**\n * Refresh _just_ this signal and its dependencies recursively.\n * All other signals will be left untouched and added to the\n * global queue to flush later. Since we're traversing \"upwards\",\n * we don't have to care about topological sorting.\n */\nfunction refreshStale(signal: Signal) {\n\tif (batchPending) {\n\t\tbatchPending.delete(signal);\n\t}\n\n\tsignal._pending = 0;\n\tsignal._updater();\n\tif (commitError) {\n\t\tconst err = commitError;\n\t\tcommitError = null;\n\t\tthrow err;\n\t}\n\n\tsignal._subs.forEach(sub => {\n\t\tif (sub._pending > 0) {\n\t\t\t// If PENDING > 1 then we can safely reduce the counter because\n\t\t\t// the final sweep will take care of the rest. But if it's\n\t\t\t// exactly 1 we can't do that otherwise the sweeping logic\n\t\t\t// assumes that this signal was already updated.\n\t\t\tif (sub._pending > 1) sub._pending--;\n\t\t\ttmpPending.push(sub);\n\t\t}\n\t});\n}\n\nfunction activate(signal: Signal) {\n\tsignal._active = true;\n\trefreshStale(signal);\n}\n\nexport function signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nexport type ReadonlySignal<T = any> = Omit<Signal<T>, \"value\"> & {\n\treadonly value: T;\n};\nexport function computed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst signal = new Signal<T>(undefined as any);\n\tsignal._readonly = true;\n\n\tfunction updater() {\n\t\tlet finish = signal._setCurrent();\n\n\t\ttry {\n\t\t\tlet ret = compute();\n\t\t\tconst stale = signal._value === ret;\n\t\t\tif (!stale) signal._subs.forEach(sub => (sub._requiresUpdate = true));\n\t\t\tfinish(stale, true);\n\t\t\tsignal._value = ret;\n\t\t} catch (err: any) {\n\t\t\t// Ensure that we log the first error not the last\n\t\t\tif (!commitError) commitError = err;\n\t\t\tfinish(true, false);\n\t\t}\n\t}\n\n\tsignal._updater = updater;\n\n\treturn signal;\n}\n\nexport function effect(callback: () => void) {\n\tconst s = computed(() => batch(callback));\n\t// Set up subscriptions since this is a \"reactor\" signal\n\tactivate(s);\n\treturn () => s._setCurrent()(true, true);\n}\n\nexport function batch<T>(cb: () => T): T {\n\tif (batchPending !== null) {\n\t\treturn cb();\n\t} else {\n\t\tconst pending: Set<Signal> = new Set();\n\n\t\tbatchPending = pending;\n\n\t\ttry {\n\t\t\treturn cb();\n\t\t} finally {\n\t\t\t// Since stale signals are refreshed upwards, we need to\n\t\t\t// add pending signals in reverse\n\t\t\tlet item: Signal | undefined;\n\t\t\twhile ((item = tmpPending.pop()) !== undefined) {\n\t\t\t\tpending.add(item);\n\t\t\t}\n\n\t\t\tbatchPending = null;\n\n\t\t\tsweep(pending);\n\t\t\tif (commitError) {\n\t\t\t\tconst err = commitError;\n\t\t\t\t// Clear global error flag for next commit\n\t\t\t\tcommitError = null;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":["currentSignal","commitError","batchPending","oldDeps","Set","Signal","value","this","_subs","_deps","_pending","_value","_readonly","_requiresUpdate","_active","_isComputing","toString","peek","activate","_setCurrent","prevSignal","prevOldDeps","shouldUnmark","shouldCleanup","_this","forEach","unmark","dep","unsubscribe","subscribe","clear","fn","_this2","_proto","_updater","key","get","add","set","Error","batch","_this3","mark","signal","sweep","subs","ready","to","from","size","tmpPending","refreshStale","err","sub","push","computed","compute","undefined","finish","ret","stale","effect","callback","s","cb","pending","item","pop"],"mappings":"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"}