{"version":3,"file":"signals-core.mjs","sources":["../src/index.ts"],"sourcesContent":["/** This tracks subscriptions of signals read inside a computed */\nlet currentSignal: Signal | undefined;\nlet commitError: Error | null = null;\n\nlet batchPending: Set<Signal> | null = null;\n\nlet oldDeps = new Set<Signal>();\n\nexport class Signal<T = any> {\n\t// These property names get minified - see /mangle.json\n\n\t/** @internal Internal, do not use. */\n\t_subs = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_deps = new Set<Signal>();\n\t/** @internal Internal, do not use. */\n\t_pending = 0;\n\t/** @internal Internal, do not use. */\n\t_value: T;\n\t/** @internal Determine if a computed is allowed to write or not */\n\t_readonly = false;\n\t/** @internal Marks the signal as requiring an update */\n\t_requiresUpdate = false;\n\t/** @internal Determine if reads should eagerly activate value */\n\t_active = false;\n\t/** @internal Used to detect if there is a cycle in the graph */\n\t_isComputing = false;\n\n\tconstructor(value: T) {\n\t\tthis._value = value;\n\t}\n\n\ttoString() {\n\t\treturn \"\" + this.value;\n\t}\n\n\tpeek() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tget value() {\n\t\tif (!this._active || this._pending > 0) {\n\t\t\tactivate(this);\n\t\t}\n\n\t\t// If we read a signal outside of a computed we have no way\n\t\t// to unsubscribe from that. So we assume that the user wants\n\t\t// to get the value immediately like for testing.\n\t\tif (!currentSignal) {\n\t\t\treturn this._value;\n\t\t}\n\n\t\t// subscribe the current computed to this signal:\n\t\tthis._subs.add(currentSignal);\n\t\t// update the current computed's dependencies:\n\t\tcurrentSignal._deps.add(this);\n\t\toldDeps.delete(this);\n\n\t\treturn this._value;\n\t}\n\n\tset value(value) {\n\t\tif (this._readonly) {\n\t\t\tthrow Error(\"Computed signals are readonly\");\n\t\t}\n\n\t\tif (this._value !== value) {\n\t\t\tthis._value = value;\n\n\t\t\tbatch(() => {\n\t\t\t\tbatchPending!.add(this);\n\n\t\t\t\t// in batch mode this signal may be marked already\n\t\t\t\tif (this._pending === 0) {\n\t\t\t\t\tmark(this);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Start a read operation where this signal is the \"current signal\" context.\n\t * Returns a function that must be called to end the read context.\n\t * @internal\n\t */\n\t_setCurrent() {\n\t\tlet prevSignal = currentSignal;\n\t\tlet prevOldDeps = oldDeps;\n\t\tcurrentSignal = this;\n\t\toldDeps = this._deps;\n\t\tthis._deps = new Set();\n\n\t\treturn (shouldUnmark: boolean, shouldCleanup: boolean) => {\n\t\t\tif (shouldUnmark) this._subs.forEach(unmark);\n\n\t\t\t// Any leftover dependencies here are not needed anymore\n\t\t\tif (shouldCleanup) {\n\t\t\t\t// Unsubscribe from dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => unsubscribe(this, dep));\n\t\t\t} else {\n\t\t\t\t// Re-subscribe to dependencies that were not accessed:\n\t\t\t\toldDeps.forEach(dep => subscribe(this, dep));\n\t\t\t}\n\n\t\t\toldDeps.clear();\n\t\t\toldDeps = prevOldDeps;\n\t\t\tcurrentSignal = prevSignal;\n\t\t};\n\t}\n\n\tsubscribe(fn: (value: T) => void): () => void {\n\t\treturn effect(() => fn(this.value));\n\t}\n\n\t/**\n\t * A custom update routine to run when this Signal's value changes.\n\t * @internal\n\t */\n\t_updater() {\n\t\t// override me to handle updates\n\t}\n}\n\nfunction mark(signal: Signal) {\n\tif (signal._pending++ === 0) {\n\t\tsignal._subs.forEach(mark);\n\t}\n}\n\nfunction unmark(signal: Signal<any>) {\n\t// We can only unmark this node as not needing an update if it\n\t// wasn't flagged as needing an update by someone else. This is\n\t// done to make the sweeping logic independent of the order\n\t// in which a dependency tries to unmark a subtree.\n\tif (\n\t\t!signal._requiresUpdate &&\n\t\tsignal._pending > 0 &&\n\t\t--signal._pending === 0\n\t) {\n\t\tsignal._subs.forEach(unmark);\n\t}\n}\n\nfunction sweep(subs: Set<Signal<any>>) {\n\tsubs.forEach(signal => {\n\t\t// If a computed errored during sweep, we'll discard that subtree\n\t\t// for this sweep cycle by setting PENDING to 0;\n\t\tif (signal._pending > 1) return --signal._pending;\n\t\tlet ready = true;\n\t\tsignal._deps.forEach(dep => {\n\t\t\tif (dep._pending > 0) ready = false;\n\t\t});\n\n\t\tif (ready && signal._pending > 0 && --signal._pending === 0) {\n\t\t\tif (signal._isComputing) {\n\t\t\t\tthrow Error(\"Cycle detected\");\n\t\t\t}\n\n\t\t\tsignal._requiresUpdate = false;\n\t\t\tsignal._isComputing = true;\n\t\t\tsignal._updater();\n\t\t\tsignal._isComputing = false;\n\t\t\tsweep(signal._subs);\n\t\t}\n\t});\n}\n\nfunction subscribe(signal: Signal<any>, to: Signal<any>) {\n\tsignal._active = true;\n\tsignal._deps.add(to);\n\tto._subs.add(signal);\n}\n\nfunction unsubscribe(signal: Signal<any>, from: Signal<any>) {\n\tsignal._deps.delete(from);\n\tfrom._subs.delete(signal);\n\n\t// If nobody listens to the signal we depended on, we can traverse\n\t// upwards and destroy all subscriptions until we encounter a writable\n\t// signal or a signal that others listen to as well.\n\tif (from._subs.size === 0) {\n\t\tfrom._active = false;\n\t\tfrom._deps.forEach(dep => unsubscribe(from, dep));\n\t}\n}\n\nconst tmpPending: Signal[] = [];\n/**\n * Refresh _just_ this signal and its dependencies recursively.\n * All other signals will be left untouched and added to the\n * global queue to flush later. Since we're traversing \"upwards\",\n * we don't have to care about topological sorting.\n */\nfunction refreshStale(signal: Signal) {\n\tif (batchPending) {\n\t\tbatchPending.delete(signal);\n\t}\n\n\tsignal._pending = 0;\n\tsignal._updater();\n\tif (commitError) {\n\t\tconst err = commitError;\n\t\tcommitError = null;\n\t\tthrow err;\n\t}\n\n\tsignal._subs.forEach(sub => {\n\t\tif (sub._pending > 0) {\n\t\t\t// If PENDING > 1 then we can safely reduce the counter because\n\t\t\t// the final sweep will take care of the rest. But if it's\n\t\t\t// exactly 1 we can't do that otherwise the sweeping logic\n\t\t\t// assumes that this signal was already updated.\n\t\t\tif (sub._pending > 1) sub._pending--;\n\t\t\ttmpPending.push(sub);\n\t\t}\n\t});\n}\n\nfunction activate(signal: Signal) {\n\tsignal._active = true;\n\trefreshStale(signal);\n}\n\nexport function signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nexport type ReadonlySignal<T = any> = Omit<Signal<T>, \"value\"> & {\n\treadonly value: T;\n};\nexport function computed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst signal = new Signal<T>(undefined as any);\n\tsignal._readonly = true;\n\n\tfunction updater() {\n\t\tlet finish = signal._setCurrent();\n\n\t\ttry {\n\t\t\tlet ret = compute();\n\t\t\tconst stale = signal._value === ret;\n\t\t\tif (!stale) signal._subs.forEach(sub => (sub._requiresUpdate = true));\n\t\t\tfinish(stale, true);\n\t\t\tsignal._value = ret;\n\t\t} catch (err: any) {\n\t\t\t// Ensure that we log the first error not the last\n\t\t\tif (!commitError) commitError = err;\n\t\t\tfinish(true, false);\n\t\t}\n\t}\n\n\tsignal._updater = updater;\n\n\treturn signal;\n}\n\nexport function effect(callback: () => void) {\n\tconst s = computed(() => batch(callback));\n\t// Set up subscriptions since this is a \"reactor\" signal\n\tactivate(s);\n\treturn () => s._setCurrent()(true, true);\n}\n\nexport function batch<T>(cb: () => T): T {\n\tif (batchPending !== null) {\n\t\treturn cb();\n\t} else {\n\t\tconst pending: Set<Signal> = new Set();\n\n\t\tbatchPending = pending;\n\n\t\ttry {\n\t\t\treturn cb();\n\t\t} finally {\n\t\t\t// Since stale signals are refreshed upwards, we need to\n\t\t\t// add pending signals in reverse\n\t\t\tlet item: Signal | undefined;\n\t\t\twhile ((item = tmpPending.pop()) !== undefined) {\n\t\t\t\tpending.add(item);\n\t\t\t}\n\n\t\t\tbatchPending = null;\n\n\t\t\tsweep(pending);\n\t\t\tif (commitError) {\n\t\t\t\tconst err = commitError;\n\t\t\t\t// Clear global error flag for next commit\n\t\t\t\tcommitError = null;\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n}\n"],"names":["currentSignal","commitError","batchPending","oldDeps","Set","Signal","constructor","value","this","_subs","_deps","_pending","_value","_readonly","_requiresUpdate","_active","_isComputing","toString","peek","activate","add","delete","Error","batch","mark","_setCurrent","prevOldDeps","shouldUnmark","shouldCleanup","forEach","unmark","dep","unsubscribe","subscribe","clear","prevSignal","fn","_updater","signal","sweep","subs","ready","to","from","size","refreshStale","err","sub","tmpPending","push","computed","compute","undefined","finish","ret","stale","effect","callback","s","cb","pending","item","pop"],"mappings":"AACA,IAAIA,EACWC,EAAiB,KAEhBC,EAAuB,KAE5BC,EAAG,IAAIC,IAELC,MAAAA,OAoBZC,YAAYC,GAAQC,KAhBpBC,GAAQ,IAgBYL,IAAAI,KAdpBE,GAAQ,IAcYN,IAAAI,KAZpBG,GAAW,EAYSH,KAVpBI,QAEAC,EAAAA,KAAAA,IAAY,EAEZC,KAAAA,IAAkB,EAElBC,KAAAA,GAAU,EAEVC,KAAAA,IAAe,EAGdR,KAAKI,GAASL,CACd,CAEDU,WACC,MAAO,GAAKT,KAAKD,KACjB,CAEDW,OAIC,QAHKV,KAAKO,GAAWP,KAAKG,GAAW,IACpCQ,EAASX,WAEEI,EACZ,CAEGL,YAQH,QAPKC,KAAKO,GAAWP,KAAKG,GAAW,IACpCQ,EAASX,MAMLR,GAKLQ,KAAKC,GAAMW,IAAIpB,GAEfA,EAAcU,GAAMU,IAAIZ,MACxBL,EAAQkB,OAAOb,MAEHI,KAAAA,SATCA,EAUb,WAESL,GACT,GAAIC,KAAKK,GACR,MAAMS,MAAM,iCAGTd,KAAKI,KAAWL,IACnBC,KAAKI,GAASL,EAEdgB,EAAM,KACLrB,EAAckB,IAAIZ,MAGI,IAAlBA,KAAKG,IACRa,EAAKhB,KACL,GAGH,CAODiB,IACC,MAAiBzB,EACF0B,EAAGvB,EAKlB,OAJAH,EAAgBQ,KAChBL,EAAUK,KAAKE,GACfF,KAAKE,GAAQ,QAEN,CAACiB,EAAuBC,KAC1BD,GAAcnB,KAAKC,GAAMoB,QAAQC,GAKpC3B,EAAQ0B,QAFLD,EAEaG,GAAOC,EAAYxB,KAAMuB,GAGzBA,GAAOE,EAAUzB,KAAMuB,IAGxC5B,EAAQ+B,QACR/B,EAAUuB,EACV1B,EAAgBmC,CAAAA,CAEjB,CAEDF,UAAUG,GACT,SAAc,IAAMA,EAAG5B,KAAKD,OAC5B,CAMD8B,KAAQ,EAKT,SAAAb,EAAcc,GACa,GAAtBA,EAAO3B,MACV2B,EAAO7B,GAAMoB,QAAQL,EAEtB,CAED,SAAAM,EAAgBQ,IAMbA,EAAOxB,IACRwB,EAAO3B,GAAW,GACI,KAApB2B,EAAO3B,IAET2B,EAAO7B,GAAMoB,QAAQC,EAEtB,CAED,SAAAS,EAAeC,GACdA,EAAKX,QAAQS,IAGZ,GAAIA,EAAO3B,GAAW,EAAG,QAAS2B,EAAO3B,GACzC,OAAY,EAKZ,GAJA2B,EAAO5B,GAAMmB,QAAQE,IAChBA,EAAIpB,GAAW,IAAG8B,GAAQ,EAC9B,GAEGA,GAASH,EAAO3B,GAAW,GAA2B,KAApB2B,EAAO3B,GAAgB,CAC5D,GAAI2B,EAAOtB,GACV,MAAWM,MAAC,kBAGbgB,EAAOxB,IAAkB,EACzBwB,EAAOtB,IAAe,EACtBsB,EAAOD,KACPC,EAAOtB,IAAe,EACtBuB,EAAMD,EAAO7B,GACb,GAEF,CAED,SAASwB,EAAUK,EAAqBI,GACvCJ,EAAOvB,GAAU,EACjBuB,EAAO5B,GAAMU,IAAIsB,GACjBA,EAAGjC,GAAMW,IAAIkB,EACb,CAED,SAAAN,EAAqBM,EAAqBK,GACzCL,EAAO5B,GAAMW,OAAOsB,GACpBA,EAAKlC,GAAMY,OAAOiB,GAKM,IAApBK,EAAKlC,GAAMmC,OACdD,EAAK5B,GAAU,EACf4B,EAAKjC,GAAMmB,QAAQE,GAAOC,EAAYW,EAAMZ,IAE7C,CAED,QAA6B,GAO7B,SAAAc,EAAsBP,GAOrB,GANIpC,GACHA,EAAamB,OAAOiB,GAGrBA,EAAO3B,GAAW,EAClB2B,EAAOD,KACHpC,EAAa,CAChB,QAAYA,EAEZ,MADAA,EAAc,KACR6C,CACN,CAEDR,EAAO7B,GAAMoB,QAAQkB,IAChBA,EAAIpC,GAAW,IAKdoC,EAAIpC,GAAW,GAAGoC,EAAIpC,KAC1BqC,EAAWC,KAAKF,GAChB,EAEF,CAED,SAAS5B,EAASmB,GACjBA,EAAOvB,GAAU,EACjB8B,EAAaP,EACb,CAEK,SAAAA,EAAoB/B,GACzB,OAAWF,IAAAA,OAAOE,EAClB,CAKe2C,SAAAA,EAAYC,GAC3B,MAAYb,EAAG,IAAIjC,YAAU+C,GAqB7B,OApBAd,EAAOzB,IAAY,EAkBnByB,EAAOD,GAhBP,WACC,IAAUgB,EAAGf,EAAOb,IAEpB,IACC,IAAO6B,EAAGH,IACV,QAAcb,EAAO1B,KAAW0C,EAC3BC,GAAOjB,EAAO7B,GAAMoB,QAAQkB,GAAQA,EAAIjC,IAAkB,GAC/DuC,EAAOE,GAAO,GACdjB,EAAO1B,GAAS0C,CAKhB,CAJC,MAAOR,GAEH7C,IAAaA,EAAc6C,GAChCO,GAAO,GAAM,EACb,CACD,EAIMf,CACP,CAEekB,SAAAA,EAAOC,GACtB,MAAOC,EAAGR,EAAS,IAAM3B,EAAMkC,IAG/B,OADAtC,EAASuC,GACF,IAAMA,EAAEjC,GAAFiC,EAAgB,GAAM,EACnC,CAEK,SAAAnC,EAAmBoC,GACxB,GAAqB,OAAjBzD,EACH,OAASyD,IACH,CACN,MAAaC,EAAgB,IAAIxD,IAEjCF,EAAe0D,EAEf,IACC,OAAOD,GAkBP,CAnBD,QAKC,IAAAE,EACA,UAAqCT,KAA7BS,EAAOb,EAAWc,QACzBF,EAAQxC,IAAIyC,GAMb,GAHA3D,EAAe,KAEfqC,EAAMqB,GACF3D,EAAa,CAChB,MAAS6C,EAAG7C,EAGZ,MADAA,EAAc,KACR6C,CACN,CACD,CACD,CACD,QAAAzC,OAAAkB,WAAA2B,cAAAM,YAAAlB"}