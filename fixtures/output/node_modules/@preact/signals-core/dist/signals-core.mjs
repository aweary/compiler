let t,i=null,n=null,s=new Set;class Signal{constructor(t){this._s=new Set,this._d=new Set,this._p=0,this._v=void 0,this._r=!1,this._q=!1,this.t=!1,this._c=!1,this._v=t}toString(){return""+this.value}peek(){return(!this.t||this._p>0)&&f(this),this._v}get value(){return(!this.t||this._p>0)&&f(this),t?(this._s.add(t),t._d.add(this),s.delete(this),this._v):this._v}set value(t){if(this._r)throw Error("Computed signals are readonly");this._v!==t&&(this._v=t,d(()=>{n.add(this),0===this._p&&e(this)}))}_(){let i=t,n=s;return t=this,s=this._d,this._d=new Set,(e,h)=>{e&&this._s.forEach(r),s.forEach(h?t=>o(this,t):t=>u(this,t)),s.clear(),s=n,t=i}}subscribe(t){return S(()=>t(this.value))}_u(){}}function e(t){0==t._p++&&t._s.forEach(e)}function r(t){!t._q&&t._p>0&&0==--t._p&&t._s.forEach(r)}function h(t){t.forEach(t=>{if(t._p>1)return--t._p;let i=!0;if(t._d.forEach(t=>{t._p>0&&(i=!1)}),i&&t._p>0&&0==--t._p){if(t._c)throw Error("Cycle detected");t._q=!1,t._c=!0,t._u(),t._c=!1,h(t._s)}})}function u(t,i){t.t=!0,t._d.add(i),i._s.add(t)}function o(t,i){t._d.delete(i),i._s.delete(t),0===i._s.size&&(i.t=!1,i._d.forEach(t=>o(i,t)))}const l=[];function c(t){if(n&&n.delete(t),t._p=0,t._u(),i){const t=i;throw i=null,t}t._s.forEach(t=>{t._p>0&&(t._p>1&&t._p--,l.push(t))})}function f(t){t.t=!0,c(t)}function a(t){return new Signal(t)}function w(t){const n=new Signal(void 0);return n._r=!0,n._u=function(){let s=n._();try{let i=t();const e=n._v===i;e||n._s.forEach(t=>t._q=!0),s(e,!0),n._v=i}catch(t){i||(i=t),s(!0,!1)}},n}function S(t){const i=w(()=>d(t));return f(i),()=>i._()(!0,!0)}function d(t){if(null!==n)return t();{const s=new Set;n=s;try{return t()}finally{let t;for(;void 0!==(t=l.pop());)s.add(t);if(n=null,h(s),i){const t=i;throw i=null,t}}}}export{Signal,d as batch,w as computed,S as effect,a as signal};//# sourceMappingURL=signals-core.mjs.map
